#!/bin/bash

# plugin_template.sh - Standardized plugin template
# Use this template for creating consistent plugins

# Standard plugin registration function
# Usage: register_standard_plugin "plugin_name" "main_function" "description"
register_standard_plugin() {
    local plugin_name="$1"
    local main_function="$2"  
    local description="$3"
    local plugin_type="${4:-internal}"
    
    # Validate inputs
    if [[ -z "$plugin_name" || -z "$main_function" || -z "$description" ]]; then
        log error "Plugin registration requires: name, function, description"
        return 1
    fi
    
    # Check if function exists
    if ! declare -f "$main_function" >/dev/null 2>&1; then
        log error "Plugin function '$main_function' not found"
        return 1
    fi
    
    # Register the plugin
    register_plugin "$plugin_name" "$main_function" "$description" "$plugin_type"
    
    # Export the function
    # shellcheck disable=SC2163  # Variable expansion needed for dynamic function export
    export -f "$main_function"
    
    log debug "Registered $plugin_type plugin: $plugin_name"
}

# Standard assertion plugin template (SECURITY: no eval)
# Usage: create_assertion_plugin "name" - creates template file
create_assertion_plugin() {
    local plugin_name="$1"
    local plugin_file="${DEFAULT_PLUGIN_DIR}/grpc_${plugin_name}.sh"
    
    # Validate plugin name
    if [[ ! "$plugin_name" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
        log error "Invalid plugin name: $plugin_name"
        return 1
    fi
    
    # Validate and create plugin directory
    if ! validate_plugin_path "$plugin_file"; then
        return 1
    fi
    
    mkdir -p "$(dirname "$plugin_file")"
    
    # Generate plugin template file (safer than eval)
    cat > "$plugin_file" << EOF
#!/bin/bash

# Custom plugin: $plugin_name
# Generated by grpctestify plugin template

assert_${plugin_name}() {
    local response="\$1"
    local args="\$2"
    
    # Standard validation
    if [[ -z "\$response" ]]; then
        log error "${plugin_name}: Empty response"
        return 1
    fi
    
    # Add your plugin-specific logic here
    # Example:
    # local field_value=\$(echo "\$response" | jq -r '.your_field')
    # [[ "\$field_value" == "\$args" ]]
    
    return 0
}

# Plugin registration
register_plugin "${plugin_name}" "assert_${plugin_name}" "Custom $plugin_name assertion" "external"

EOF
    
    chmod 644 "$plugin_file"
    log success "Plugin template created: $plugin_file"
}

# Plugin metadata helper
set_plugin_metadata() {
    local plugin_name="$1"
    local version="$2"
    local author="$3"
    
    local version_var="PLUGIN_${plugin_name^^}_VERSION"
    local author_var="PLUGIN_${plugin_name^^}_AUTHOR"
    
    declare -g "$version_var"="$version"
    declare -g "$author_var"="$author"
}
